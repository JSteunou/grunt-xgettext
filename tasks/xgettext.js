/*
 * grunt-gettext
 * https://github.com/arendjr/grunt-gettext
 *
 * Copyright (c) 2013 Arend van Beelen, Speakap BV
 * Licensed under the MIT license.
 */

"use strict";

module.exports = function(grunt) {

    var _ = grunt.util._;

    function escapeString(string) {

        return '"' + string.replace(/"/g, '\\"') + '"';
    }

    var extractors = {
        handlebars: function(file, options) {
            var contents = grunt.file.read(file).replace("\n", " ");

            var fn = _.flatten([ options.functionName ]);

            var messages = {}, result;

            var extractStrings = function(quote, fn) {
                var regex = new RegExp("\\{\\{\\s*" + fn + "\\s+((?:" +
                    quote + "(?:[^" + quote + "\\\\]|\\\\.)+" + quote +
                    "\\s*)+)[^}]*\\s*\\}\\}", "g");
                var subRE = new RegExp(quote + "((?:[^" + quote + "\\\\]|\\\\.)+)" + quote, "g");
                var quoteRegex = new RegExp("\\\\" + quote, "g");
                // need to factorize
                while ((result = regex.exec(contents)) !== null) {
                    var strings = result[1],
                        singular = void 0;
                    while ((result = subRE.exec(strings)) !== null) {
                        var string = options.processMessage(result[1].replace(quoteRegex, quote));
                        // if singular form already defined add message as plural
                        if (singular !== void 0) {
                            messages[singular].plural = string;
                        // if not defined init message object
                        } else {
                            singular = string;
                            messages[string] = {
                                singular: singular,
                                message: ""
                            };
                        }
                    }
                }
            };

            _.each( fn, function( func ) {
                extractStrings("'", func );
                extractStrings('"', func );
            });

            return messages;
        },

        javascript: function(file, options) {
            var contents = grunt.file.read(file).replace("\n", " ")
                .replace(/"\s*\+\s*"/g, "")
                .replace(/'\s*\+\s*'/g, "");

            var fn = _.flatten([ options.functionName ]);

            var messages = {}, result;

            var extractStrings = function(quote, fn) {
                var regex = new RegExp("(?:[^\\w]|^)" + fn + "\\s*\\(\\s*((?:" +
                    quote + "(?:[^" + quote + "\\\\]|\\\\.)+" + quote +
                    "\\s*[,)]\\s*)+)", "g");
                var subRE = new RegExp(quote + "((?:[^" + quote + "\\\\]|\\\\.)+)" + quote, "g");
                var quoteRegex = new RegExp("\\\\" + quote, "g");
                // need to factorize
                while ((result = regex.exec(contents)) !== null) {
                    var strings = result[1],
                        singular = void 0;
                    while ((result = subRE.exec(strings)) !== null) {
                        var string = options.processMessage(result[1].replace(quoteRegex, quote));
                        // if singular form already defined add message as plural
                        if (singular !== void 0) {
                            messages[singular].plural = string;
                        // if not defined init message object
                        } else {
                            singular = string;
                            messages[string] = {
                                singular: singular,
                                message: ""
                            };
                        }
                    }
                }
            };

            _.each( fn, function( func ) {
                extractStrings("'", func );
                extractStrings('"', func );
            });

            return messages;
        }
    };

    grunt.registerMultiTask("xgettext", "Extracts translatable messages", function() {

        var options = this.options({
            functionName: "tr",
            potFile: "messages.pot",
            processMessage: _.identity
        });

        var translations = {};

        this.files.forEach(function(f) {

            if (!extractors.hasOwnProperty(f.dest)) {
                console.log("No gettext extractor for type: " + f.dest);
                return;
            }

            var messages = {};
            f.src.forEach(function(file) {
                _.extend(messages, extractors[f.dest](file, options));
            });

            _.extend(translations, messages);

            var count = Object.keys(messages).length;
            grunt.log.writeln("Extracted " + count + " messages from " + f.dest + " files.");
        });

        var contents = "# Generated by grunt-xgettext on " + (new Date()).toString() + "\n\n";

        contents += _.map(translations, function(definition) {
            var buffer = "msgid " + escapeString(definition.singular) + "\n";
            if (definition.plural) {
                buffer += "msgid_plural " + escapeString(definition.plural) + "\n";
                buffer += "msgstr[0] " + escapeString(definition.message) + "\n";
            } else {
                buffer += "msgstr " + escapeString(definition.message) + "\n";
            }
            return buffer;
        }).join("\n");

        grunt.file.write(options.potFile, contents);

        var count = Object.keys(translations).length;
        grunt.log.writeln(count + " messages successfully extracted, " +
            options.potFile + " written.");

    });

};
